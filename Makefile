# SPDX-License-Identifier: GPL-2.0-only
# Standalone Makefile for schedscore (uses pkg-config libbpf and system bpftool)

# ---- Optional configuration file (generated by ./configure)
-include config.mk

# ---- Compilers/flags
CLANG        ?= clang
CC           ?= cc
PKG_CONFIG   ?= pkg-config
CFLAGS       ?= -O2 -g -Wall -Wextra
CPPFLAGS     ?=
LDFLAGS      ?=
LDLIBS       ?=

# Treat warnings as errors by default to catch issues early
STRICT ?= 1
ifeq ($(STRICT),1)
  CFLAGS += -Werror
endif

# ---- Prefer in-tree libbpf/bpftool when building inside tools/ (to avoid version mismatches)
PREFER_INTREE ?= auto
USE_INTREE    :=
ifeq ($(PREFER_INTREE),auto)
  ifneq (,$(wildcard ../lib/bpf/Makefile))
    USE_INTREE := 1
  endif
else ifeq ($(PREFER_INTREE),1)
  USE_INTREE := 1
endif

ifeq ($(USE_INTREE),1)
  TOOLS_DIR   := ..
  LIBBPF_DIR  := $(TOOLS_DIR)/lib/bpf
  LIBBPF_A    := $(LIBBPF_DIR)/libbpf.a
  BPFTOOL_DIR := $(TOOLS_DIR)/bpf/bpftool
  BPFTOOL_BIN := $(BPFTOOL_DIR)/bpftool
  CPPFLAGS    += -I$(LIBBPF_DIR) -I$(LIBBPF_DIR)/include/uapi -I$(LIBBPF_DIR)/include
  LDLIBS      += -lelf -lz -lpthread
else
  # Resolve libbpf via pkg-config (unless provided via config.mk)
  LIBBPF_CFLAGS ?= $(shell $(PKG_CONFIG) --cflags libbpf 2>/dev/null)
  LIBBPF_LIBS   ?= $(shell $(PKG_CONFIG) --libs   libbpf 2>/dev/null)
  CPPFLAGS      += $(LIBBPF_CFLAGS)
  LDLIBS        += $(LIBBPF_LIBS)
  # Resolve bpftool from PATH (or config.mk)
  BPFTOOL_BIN   ?= $(shell command -v bpftool 2>/dev/null)
endif

# ---- Our sources/outputs
USERBIN      := schedscore
USEROBJ      := schedscore.o emit_helpers.o output_table.o output_csv.o output_json.o output_dispatch.o opts_parse.o topo.o

BPF_C        := schedscore.bpf.c
BPF_O        := schedscore.bpf.o
BPF_SKEL_H   := schedscore.skel.h
VMLINUX_H    := vmlinux.h

# Default target
all: deps $(USERBIN)

# ---- Dependency checks and in-tree fallbacks
ifeq ($(USE_INTREE),1)
  deps: $(LIBBPF_A) $(BPFTOOL_BIN)
  $(LIBBPF_A):
	$(MAKE) -C $(LIBBPF_DIR)
  $(BPFTOOL_BIN):
	$(MAKE) -C $(BPFTOOL_DIR)
else
  deps:
	@if [ -z "$(LIBBPF_LIBS)" ]; then \
		echo "ERROR: libbpf not found via pkg-config. Install libbpf-dev or run ./configure, or set LIBBPF_CFLAGS/LIBBPF_LIBS."; \
		exit 1; \
		fi
	@if [ -z "$(BPFTOOL_BIN)" ]; then \
		echo "ERROR: bpftool not found in PATH. Install bpftool or run ./configure to set BPFTOOL."; \
		exit 1; \
		fi
endif

# ---- Generate vmlinux.h from chosen BTF source (default: /sys, overridable)
VMLINUX_BTF ?= /sys/kernel/btf/vmlinux
$(VMLINUX_H): | deps
	@if [ ! -r "$(VMLINUX_BTF)" ]; then \
		echo "ERROR: $(VMLINUX_BTF) not found (set VMLINUX_BTF to a valid vmlinux or vmlinux.btf)"; \
		exit 1; \
	fi
	$(BPFTOOL_BIN) btf dump file "$(VMLINUX_BTF)" format c > $@

# ---- Build BPF object and skeleton
# Ensure user objects that include the skeleton are built after it exists
output_table.o: $(BPF_SKEL_H)
output_csv.o:   $(BPF_SKEL_H)
output_json.o:  $(BPF_SKEL_H)
output_dispatch.o: $(BPF_SKEL_H)

BPF_CLANG_FLAGS ?= -O2 -g -target bpf -fno-merge-constants
$(BPF_O): $(BPF_C) $(VMLINUX_H)
	$(CLANG) $(BPF_CLANG_FLAGS) $(CPPFLAGS) -c $< -o $@

$(BPF_SKEL_H): $(BPF_O) | deps
	$(BPFTOOL_BIN) gen skeleton $< > $@

# ---- Build userspace
schedscore.o: schedscore.c $(BPF_SKEL_H)
		$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

opts_parse.o: opts_parse.c opts_parse.h opts.h
		$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

topo.o: topo.c topo.h $(BPF_SKEL_H)
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

output_table.o: output_table.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
output_csv.o: output_csv.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
output_json.o: output_json.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
output_dispatch.o: output_dispatch.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@

ifeq ($(USE_INTREE),1)
$(USERBIN): $(USEROBJ) $(LIBBPF_A)
	$(CC) $(CFLAGS) $(USEROBJ) $(LIBBPF_A) $(LDFLAGS) $(LDLIBS) -o $@
else
$(USERBIN): $(USEROBJ)
	$(CC) $(CFLAGS) $(USEROBJ) $(LDFLAGS) $(LDLIBS) -o $@
endif

# Optional static binary (fully static; requires static libc and static libbpf)
USERBIN_STATIC := schedscore-static

ifeq ($(USE_INTREE),1)
$(USERBIN_STATIC): $(USEROBJ) $(LIBBPF_A)
	$(CC) $(CFLAGS) $(USEROBJ) $(LIBBPF_A) $(LDFLAGS) -static $(LDLIBS) -o $@
else
$(USERBIN_STATIC): $(USEROBJ)
	$(CC) $(CFLAGS) $(USEROBJ) $(LDFLAGS) -static $(LDLIBS) -o $@
endif

# Build a static binary via: make static

# ---- Static MUSL build (portable static binary)
MUSL_CC        ?= musl-gcc
MUSL_PKG_CONFIG?= pkg-config
MUSL_CFLAGS    ?= $(CFLAGS)
# Pick up libbpf cflags for musl toolchain as well
MUSL_LIBBPF_CFLAGS := $(shell $(MUSL_PKG_CONFIG) --cflags libbpf 2>/dev/null)
MUSL_CPPFLAGS  ?= $(CPPFLAGS) $(MUSL_LIBBPF_CFLAGS)
MUSL_LDFLAGS   ?= $(LDFLAGS)
# Use pkg-config --static to pick static dependencies for libbpf
MUSL_LDLIBS    ?= $(shell $(MUSL_PKG_CONFIG) --static --libs libbpf 2>/dev/null)

USEROBJ_MUSL   := schedscore.musl.o
USERBIN_MUSL   := schedscore-static-musl

.PHONY: static-musl check-musl
# ---- Dockerized static builds for distro targets
.PHONY: dist

# Build static binaries inside Docker for Ubuntu 22.04 and 24.04
# Requires Docker to be available on host. Artifacts go in dist/<label>/
dist:
	@bash scripts/build-static-in-docker.sh ubuntu:22.04 ubuntu:24.04


check-musl:
	@if ! command -v $(MUSL_CC) >/dev/null 2>&1; then \
		echo "ERROR: $(MUSL_CC) not found. Install musl-tools (musl-gcc)."; exit 1; \
	fi
	@if [ -z "$(MUSL_LDLIBS)" ]; then \
		echo "ERROR: pkg-config --static --libs libbpf returned empty. Install static libbpf (e.g., libbpf-static)."; exit 1; \
	fi

$(USEROBJ_MUSL): schedscore.c $(BPF_SKEL_H)
	$(MUSL_CC) $(MUSL_CFLAGS) $(MUSL_CPPFLAGS) -c $< -o $@

$(USERBIN_MUSL): $(USEROBJ_MUSL)
	$(MUSL_CC) $(MUSL_CFLAGS) $(USEROBJ_MUSL) $(MUSL_LDFLAGS) -static $(MUSL_LDLIBS) -o $@

static-musl: deps check-musl $(USERBIN_MUSL)

.PHONY: static
static: deps $(USERBIN_STATIC)

# ---- Clean
clean:
	$(RM) -f $(USERBIN) $(USEROBJ) $(BPF_O) $(BPF_SKEL_H) $(VMLINUX_H)

# ---- Tests
.PHONY: test
TEST_SCRIPT := ./test_schedscore.sh

test: all $(TEST_SCRIPT)

# ---- Unit tests for output formatters (snapshot-based, no libbpf)
.PHONY: unit-test
UNIT_TESTS := tests/test_output_table tests/test_output_csv tests/test_output_json

unit-test: $(UNIT_TESTS)
	@for t in $(UNIT_TESTS); do echo "RUN $$t"; ./$$t; done

# simple build rule
tests/%: tests/%.c output_common.o
	$(CC) $(CFLAGS) -I. $^ -o $@

	@bash $(TEST_SCRIPT)

.PHONY: all clean deps
